pipeline {
    agent any

    stages {
        stage('Checkout Code') {
            steps {
                // Checkout code from the Git repository
                checkout scm
            }
        }

        stage('Generate Image Tag') {
            steps {
                script {
                    // Generate the image tag based on the current datetime
                    def now = new Date()
                    def formattedDate = now.format("yyyyMMdd-HHmmss")
                    env.IMAGE_TAG = formattedDate
                }
            }
        }

        stage('Load Global Configuration') {
            steps {
                script {
                    // Load service-specific configuration from config.groovy
                    def config = evaluate(readFile('Environments/Jenkins/global-config.groovy'))

                    // Set environment variables from the configuration
                    env.KUBECONFIG = config.KUBECONFIG
                    env.KUBE_CONTEXT = config.KUBE_CONTEXT
                    env.DOCKER_CREDENTIAL_ID = config.DOCKER_CREDENTIAL_ID
                    env.NAMESPACE = config.NAMESPACE
                }
            }
        }

        stage('Load Specific Configuration') {
            steps {
                script {
                    // Load service-specific configuration from config.groovy
                    def config = evaluate(readFile('./Environments/Jenkins/UserService/config.groovy'))

                    // Set environment variables from the configuration
                    env.IMAGE_NAME = config.IMAGE_NAME
                    env.DOCKERFILE = config.DOCKERFILE
                    env.SECRET_CONFIGMAP_PATH = config.SECRET_CONFIGMAP_PATH
                    env.SERVICES_PATH = config.SERVICES_PATH

                    // Set environment variables for SQL and User Service
                    env.SQL_DEPLOYMENT_NAME = config.SQL_DEPLOYMENT_NAME
                    env.SQL_CONTAINER_NAME = config.SQL_CONTAINER_NAME
                    env.SQL_IMAGE = config.SQL_IMAGE
                    env.SQL_PORT = config.SQL_PORT.toString()
                    env.SQL_REPLICAS = config.SQL_REPLICAS.toString()
                    env.SQL_SECRET_NAME = config.SQL_SECRET_NAME
                    env.SQL_SECRET_PASSWORD_KEY = config.SQL_SECRET_PASSWORD_KEY
                    env.SQL_MEMORY_REQUEST = config.SQL_MEMORY_REQUEST
                    env.SQL_CPU_REQUEST = config.SQL_CPU_REQUEST
                    env.SQL_MEMORY_LIMIT = config.SQL_MEMORY_LIMIT
                    env.SQL_CPU_LIMIT = config.SQL_CPU_LIMIT
                    env.SQL_SERVICE_NAME = config.SQL_SERVICE_NAME

                    env.USER_DEPLOYMENT_NAME = config.USER_DEPLOYMENT_NAME
                    env.USER_CONTAINER_NAME = config.USER_CONTAINER_NAME
                    env.USER_PORT = config.USER_PORT.toString()
                    env.USER_REPLICAS = config.USER_REPLICAS.toString()
                    env.USER_ENVIRONMENT = config.USER_ENVIRONMENT
                    env.USER_DATABASE = config.USER_DATABASE
                    env.USER_SECRET_NAME = config.USER_SECRET_NAME
                    env.USER_SECRET_PASSWORD_KEY = config.USER_SECRET_PASSWORD_KEY
                    env.USER_SERVICE_NAME = config.USER_SERVICE_NAME
                    env.USER_NODE_PORT = config.USER_NODE_PORT.toString()
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    // Build Docker image from Dockerfile
                    sh "docker build -t ${env.IMAGE_NAME}:${env.IMAGE_TAG} ./src -f ${env.DOCKERFILE}"
                }
            }
        }

        stage('Push Docker Image') {
            steps {
                script {
                    docker.withRegistry("https://index.docker.io/v1/", "${env.DOCKER_CREDENTIAL_ID}") {
                        // Push the Docker image to the registry
                        sh "docker push ${env.IMAGE_NAME}:${env.IMAGE_TAG}"
                    }
                }
            }
        }

        stage('Deploy Secrets and ConfigMaps') {
            steps {
                script {
                    def secretFiles = findFiles(glob: "${env.SECRET_CONFIGMAP_PATH}")
                    secretFiles.each { file ->
                        echo "Applying secret or configmap: ${file.path}"
                        echo "Checking contexts"
                        echo "kubectl config get-contexts"
                        sh "kubectl get nodes"
                        sh "kubectl --context=${env.KUBE_CONTEXT} apply -f ${file.path} -n ${env.NAMESPACE}"
                    }
                }
            }
        }

        stage('Deploy Services') {
            steps {
                script {
                    def serviceFiles = findFiles(glob: "${env.SERVICES_PATH}")
                    serviceFiles.each { file ->
                        echo "Applying Service and Deployment: ${file.path}"

                        // Replace placeholders in each service file based on the ddconfig
                        def serviceYAML = readFile(file.path)
                        serviceYAML = serviceYAML.replaceAll(/\$\{([A-Z_]+)\}/) { env[it[1]] }

                        // Write the modified YAML back and apply it
                        writeFile file: file.path, text: serviceYAML
                        sh "kubectl --context=${KUBE_CONTEXT} apply -f ${file.path} -n ${env.NAMESPACE}"
                    }
                }
            }
        }
    }

    // post {
    //     always {
    //         // Clean up the workspace after the job is completed
    //         cleanWs()
    //     }
    // }
}
